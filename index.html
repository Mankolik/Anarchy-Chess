<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chess – P2P Web (no server)</title>
<style>
  :root { --sq: clamp(42px, 11vw, 76px); --light:#f0d9b5; --dark:#b58863; --hl:#e8f36a; --sel:#7bd3ff; }
  * { box-sizing: border-box }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;margin:0;display:flex;justify-content:center;align-items:center;min-height:100vh;background:#0f1115;color:#eaeaea}
  .wrap{display:flex;gap:20px;align-items:flex-start;flex-wrap:wrap;padding:14px;max-width:1200px}
  #board{display:grid;grid-template-columns:repeat(8,var(--sq));grid-template-rows:repeat(8,var(--sq));border:6px solid #2b2f36;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.4);user-select:none;touch-action:manipulation}
  .sq{width:var(--sq);height:var(--sq);display:flex;align-items:center;justify-content:center;position:relative;cursor:pointer;transition:transform .05s}
  .sq:hover{transform:scale(1.02)}
  .light{background:var(--light)} .dark{background:var(--dark)}
  .sel{box-shadow:inset 0 0 0 4px var(--sel)}
  .dot{position:absolute;width:16px;height:16px;border-radius:50%;background:#0008}
  .target{position:absolute;inset:4px;border:4px solid #0008;border-radius:8px}
  .panel{min-width:280px;background:#151821;border:1px solid #2b2f36;border-radius:12px;padding:14px}
  .tag{display:inline-block;padding:4px 8px;border-radius:999px;background:#243048;margin-right:8px}
  button{background:#2b2f36;color:#eaeaea;border:1px solid #3b4252;border-radius:8px;padding:9px 12px;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  button:hover{background:#394150}
  .moves{max-height:320px;overflow:auto;margin-top:8px;font-variant-numeric:tabular-nums}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  textarea{width:100%;background:#0f1115;border:1px solid #2b2f36;color:#eaeaea;border-radius:8px;padding:8px}
  dialog{border:none;border-radius:12px;padding:0;overflow:hidden;max-width:min(680px, 96vw)}
  .modal{background:#111826;color:#fff;border:1px solid #2b2f36}
  .modal header{padding:12px 16px;border-bottom:1px solid #2b2f36;font-weight:600}
  .modal .body{padding:12px 16px}
  .promos{display:flex;gap:12px;margin-top:8px}
  .promo{font-size:36px;padding:6px 10px;border-radius:10px;background:#1c2230;cursor:pointer}
  .promo:hover{background:#2a3245}
  .qr{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .qr img{width:min(220px, 50vw);height:auto;border-radius:8px;border:1px solid #2b2f36;background:#fff}
  .hint{opacity:.8;font-size:.9em}
  .piece{width:80%;height:80%;pointer-events:none} /* SVG pieces */
</style>
</head>
<body>
<div class="wrap">
  <div id="board" aria-label="Chess board"></div>
  <div class="panel">
    <div class="row" style="justify-content:space-between;">
      <div class="tag" id="turnTag">Turn: White</div>
      <div class="tag" id="statusTag">Ready</div>
    </div>
    <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="newBtn">New game</button>
      <button id="undoBtn">Undo</button>
      <button id="flipBtn">Flip board</button>
    </div>
    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="hostBtn">Host online</button>
      <button id="joinBtn">Join online</button>
    </div>
    <div style="margin-top:12px;font-weight:600">Moves (SAN)</div>
    <div id="moves" class="moves"></div>
  </div>
</div>

<!-- Promotion -->
<dialog id="promoDlg" class="modal">
  <header>Choose promotion</header>
  <div class="body">
    <div class="promos">
      <div class="promo" data-p="q">♕</div>
      <div class="promo" data-p="r">♖</div>
      <div class="promo" data-p="b">♗</div>
      <div class="promo" data-p="n">♘</div>
    </div>
  </div>
</dialog>

<!-- Host dialog -->
<dialog id="hostDlg" class="modal">
  <header>Share this offer</header>
  <div class="body">
    <p>Send this code to your opponent. Then paste their answer below and press <b>Connect</b>.</p>
    <textarea id="offerOut" rows="6" readonly></textarea>
    <div class="qr">
      <img id="offerQR" alt="Offer QR"/>
      <div class="hint">Tip: On mobile, tap <b>Copy</b> and share via chat. QR works too, but very long codes can be dense.</div>
    </div>
    <textarea id="answerIn" rows="6" placeholder="Paste answer here"></textarea>
    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="copyOfferBtn">Copy</button>
      <button id="connectBtn">Connect</button>
      <button onclick="hostDlg.close()">Close</button>
    </div>
  </div>
</dialog>

<!-- Join dialog -->
<dialog id="joinDlg" class="modal">
  <header>Paste host offer</header>
  <div class="body">
    <textarea id="offerIn" rows="6" placeholder="Paste offer here"></textarea>
    <p>Your answer (send this back to host):</p>
    <textarea id="answerOut" rows="6" readonly></textarea>
    <div class="qr">
      <img id="answerQR" alt="Answer QR"/>
      <div class="hint">The host can scan this QR or you can tap <b>Copy</b> and send it.</div>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="copyAnswerBtn">Copy</button>
      <button onclick="joinDlg.close()">Close</button>
    </div>
  </div>
</dialog>

<script>
/* ---------- Helpers ---------- */
const startFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
const files = "abcdefgh";
function inb(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function algebraic(r,c){ return files[c] + (8-r); }
function fromAlg(a){ return [8-parseInt(a[1]), files.indexOf(a[0])]; }
function colorOf(p){ return p ? p[0] : null; }

/* ---------- Pieces (uniform SVG set) ---------- */
const PIECE_IMG = (p) => `https://raw.githubusercontent.com/lichess-org/lila/master/public/piece/cburnett/${p}.svg`;

/* ---------- Game State ---------- */
let state = {};
let history = [];
let flipped = false;

function loadFEN(fen){
  const [pieces, active, castling, ep, half, full] = fen.split(' ');
  const board = Array.from({length:8}, ()=>Array(8).fill(null));
  let r=0,c=0;
  for(const ch of pieces){
    if(ch==='/'){ r++; c=0; continue; }
    if(/\\d/.test(ch)){ c += parseInt(ch); continue; }
    const col = (ch === ch.toUpperCase()) ? 'w' : 'b';
    const type = ch.toUpperCase();
    board[r][c++] = col + type;
  }
  state = {
    board,
    active: active || 'w',
    castling: {K:castling?.includes('K'), Q:castling?.includes('Q'),
               k:castling?.includes('k'), q:castling?.includes('q')},
    ep: ep==='-' ? null : ep,
    half: parseInt(half||0), full: parseInt(full||1)
  };
  history = [];
  draw();
}

function pieceChar(p){
  const t = p[1];
  return p[0]==='w' ? t : t.toLowerCase();
}

function toFEN(s=state){
  const rows=[];
  for(let r=0;r<8;r++){
    let row='', empty=0;
    for(let c=0;c<8;c++){
      const p=s.board[r][c];
      if(!p){ empty++; continue; }
      if(empty){ row+=empty; empty=0; }
      row += pieceChar(p);
    }
    if(empty) row+=empty;
    rows.push(row);
  }
  const cast = (s.castling.K?'K':'')+(s.castling.Q?'Q':'')+(s.castling.k?'k':'')+(s.castling.q?'q':'') || '-';
  return `${rows.join('/')} ${s.active} ${cast} ${s.ep||'-'} ${s.half} ${s.full}`;
}

/* ---------- Move Generation ---------- */
const DIRS = {
  N:[[ -2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
  B:[[-1,-1],[-1,1],[1,-1],[1,1]],
  R:[[-1,0],[1,0],[0,-1],[0,1]],
  K:[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
};

function squareAttacked(s, r, c, byColor){
  for(const [dr,dc] of DIRS.N){
    const rr=r+dr, cc=c+dc;
    if(!inb(rr,cc)) continue;
    const p=s.board[rr][cc];
    if(p && colorOf(p)===byColor && p[1]==='N') return true;
  }
  const lines = [
    {dirs:DIRS.B, attackers:['B','Q']},
    {dirs:DIRS.R, attackers:['R','Q']}
  ];
  for(const {dirs,attackers} of lines){
    for(const [dr,dc] of dirs){
      let rr=r+dr, cc=c+dc;
      while(inb(rr,cc)){
        const p=s.board[rr][cc];
        if(p){
          if(colorOf(p)===byColor && attackers.includes(p[1])) return true;
          break;
        }
        rr+=dr; cc+=dc;
      }
    }
  }
  for(const [dr,dc] of DIRS.K){
    const rr=r+dr, cc=c+dc;
    if(!inb(rr,cc)) continue;
    const p=s.board[rr][cc];
    if(p && colorOf(p)===byColor && p[1]==='K') return true;
  }
  const dir = (byColor==='w')? -1 : 1;
  for(const dc of [-1,1]){
    const rr=r+dir, cc=c+dc;
    if(!inb(rr,cc)) continue;
    const p=s.board[rr][cc];
    if(p && colorOf(p)===byColor && p[1]==='P') return true;
  }
  return false;
}

function kingPos(s, col){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=s.board[r][c]; if(p && p[0]===col && p[1]==='K') return [r,c];
  }
  return null;
}
function inCheck(s, col){ const k=kingPos(s,col); return k ? squareAttacked(s,k[0],k[1],col==='w'?'b':'w') : false; }

function genMoves(s){
  const moves=[];
  const side = s.active;
  const opp = side==='w'?'b':'w';
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=s.board[r][c]; if(!p || p[0]!==side) continue;
    const add=(rr,cc,opts={})=>{
      if(!inb(rr,cc)) return;
      const t=s.board[rr][cc];
      if(!t || colorOf(t)!==side) moves.push({from:[r,c], to:[rr,cc], piece:p, capture:!!t, ...opts});
    };
    switch(p[1]){
      case 'P':{
        const dir = (side==='w')?-1:1;
        const startRow = (side==='w')?6:1;
        const promoRow = (side==='w')?0:7;
        const f1r=r+dir, f2r=r+2*dir;
        if(inb(f1r,c) && !s.board[f1r][c]){
          add(f1r,c,{promotion:f1r===promoRow});
          if(r===startRow && !s.board[f2r]?.[c]) add(f2r,c,{double:true});
        }
        for(const dc of [-1,1]){
          const rr=r+dir, cc=c+dc;
          if(!inb(rr,cc)) continue;
          const t=s.board[rr][cc];
          if(t && colorOf(t)===opp) add(rr,cc,{capture:true, promotion: rr===promoRow});
        }
        if(s.ep){
          const [epr,epc]=fromAlg(s.ep);
          if(f1r===epr && Math.abs(epc-c)===1) add(epr,epc,{enpassant:true,capture:true});
        }
        // Own Passant: capture your own pawn by moving diagonally backwards
        if(s.ep){
          const [epr,epc]=fromAlg(s.ep);
          // The pawn that just double-moved is one square ahead from ep square (in movement direction)
          const doubleMovedRow = epr + dir;
          const targetPawn = s.board[doubleMovedRow]?.[epc];
          // Check if the pawn that double-moved is ours (same color)
          if(targetPawn && colorOf(targetPawn) === side && targetPawn[1] === 'P'){
            // Check if current pawn is next to the double-moved pawn (same row, adjacent file)
            if(r === doubleMovedRow && Math.abs(epc - c) === 1){
              // Can capture by moving diagonally backwards to ep square
              add(epr, epc, {ownpassant:true, capture:true});
            }
          }
        }
      } break;
      case 'N': for(const [dr,dc] of DIRS.N) add(r+dr,c+dc); break;
      case 'B':
      case 'R':
      case 'Q':{
        const dirs = p[1]==='B'?DIRS.B : p[1]==='R'?DIRS.R : DIRS.B.concat(DIRS.R);
        for(const [dr,dc] of dirs){
          let rr=r+dr, cc=c+dc;
          while(inb(rr,cc)){
            const t=s.board[rr][cc];
            add(rr,cc);
            if(t) break;
            rr+=dr; cc+=dc;
          }
        }
      } break;
      case 'K':{
        for(const [dr,dc] of DIRS.K) add(r+dr,c+dc);
        if(!inCheck(s,side)){
          const row = side==='w'?7:0;
          if((side==='w'?s.castling.K:s.castling.k) && !s.board[row][5] && !s.board[row][6] &&
             !squareAttacked(s,row,5,opp) && !squareAttacked(s,row,6,opp))
            moves.push({from:[r,c],to:[row,6],piece:p,castle:'K'});
          if((side==='w'?s.castling.Q:s.castling.q) && !s.board[row][1] && !s.board[row][2] && !s.board[row][3] &&
             !squareAttacked(s,row,2,opp) && !squareAttacked(s,row,3,opp))
            moves.push({from:[r,c],to:[row,2],piece:p,castle:'Q'});
        }
      } break;
    }
  }
  const legal=[];
  for(const m of moves){
    const s2 = structuredClone(s);
    makeMove(s2, m, true);
    if(!inCheck(s2, side)) legal.push(m);
  }
  return legal;
}

/* ---------- Make/Undo ---------- */
function makeMove(s, m, dry=false){
  // ✅ Only a KING move may castle; ignore castle flag otherwise
  if (m.castle && (!m.piece || m.piece[1] !== 'K')) {
    m.castle = undefined;
  }

  const b=s.board;
  const [fr,fc]=m.from, [tr,tc]=m.to;
  const side = s.active;
  const opp = side==='w'?'b':'w';

  s.ep = null;

  const capturedSquare = {r:tr, c:tc};

  if(m.enpassant || m.ownpassant){
    const dir = side==='w'?-1:1;
    b[tr - dir][tc] = null;
  }
  if(m.castle==='K'){
    const row = side==='w'?7:0;
    b[row][5] = b[row][7]; b[row][7]=null;
  }
  if(m.castle==='Q'){
    const row = side==='w'?7:0;
    b[row][3] = b[row][0]; b[row][0]=null;
  }

  const moving = b[fr][fc];
  const captured = b[tr][tc];
  b[tr][tc] = moving;
  b[fr][fc] = null;

  if(m.promotion){
    const promo = m.promoteTo || 'Q';
    b[tr][tc] = side + promo;
  }

  if(m.double){
    const epRow = side==='w' ? tr+1 : tr-1;
    s.ep = algebraic(epRow, tc);
  }

  if(moving === 'wK'){ s.castling.K=false; s.castling.Q=false; }
  if(moving === 'bK'){ s.castling.k=false; s.castling.q=false; }
  if(moving === 'wR' && fr===7 && fc===0) s.castling.Q=false;
  if(moving === 'wR' && fr===7 && fc===7) s.castling.K=false;
  if(moving === 'bR' && fr===0 && fc===0) s.castling.q=false;
  if(moving === 'bR' && fr===0 && fc===7) s.castling.k=false;

  if(captured){
    if(capturedSquare.r===7 && capturedSquare.c===0) s.castling.Q=false;
    if(capturedSquare.r===7 && capturedSquare.c===7) s.castling.K=false;
    if(capturedSquare.r===0 && capturedSquare.c===0) s.castling.q=false;
    if(capturedSquare.r===0 && capturedSquare.c===7) s.castling.k=false;
  }

  if(moving[1]==='P' || captured) s.half=0; else s.half++;
  if(side==='b') s.full++;
  s.active = opp;

  return s;
}

/* ---------- SAN & Result ---------- */
function isCheckmate(s){ return genMoves(s).length===0 && inCheck(s, s.active); }
function isStalemate(s){ return genMoves(s).length===0 && !inCheck(s, s.active); }
function pieceLetter(p){ return p[1]==='P' ? '' : p[1]; }

function toSAN(prev, m, after){
  const addCheck = (txt)=>{
    if(isCheckmate(after)) return txt + '#';
    if(inCheck(after, after.active)) return txt + '+';
    return txt;
  };
  if(m.castle==='K') return addCheck('O-O');
  if(m.castle==='Q') return addCheck('O-O-O');
  let san = '';
  if(m.piece[1]==='P' && m.capture) san += algebraic(m.from[0], m.from[1])[0];
  // disambiguation
  let dis='';
  const sameTypeFrom = [];
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=prev.board[r][c];
    if(p && p===m.piece && !(r===m.from[0]&&c===m.from[1])){
      const legals = genMoves(prev).filter(x => x.piece===p && x.to[0]===m.to[0] && x.to[1]===m.to[1]);
      if(legals.length) sameTypeFrom.push([r,c]);
    }
  }
  if(pieceLetter(m.piece) && sameTypeFrom.length){
    const needFile = !sameTypeFrom.every(x=>x[1]===m.from[1]);
    const needRank = !sameTypeFrom.every(x=>x[0]===m.from[0]);
    const fromA = algebraic(m.from[0], m.from[1]);
    dis = needFile && needRank ? fromA : (needFile ? fromA[0] : fromA[1]);
  }
  san = pieceLetter(m.piece) + dis + (m.capture?'x':'') + algebraic(m.to[0], m.to[1]);
  if(m.promotion) san += '=' + (m.promoteTo || 'Q');
  return addCheck(san);
}

/* ---------- UI ---------- */
const boardEl = document.getElementById('board');
const movesEl = document.getElementById('moves');
const turnTag = document.getElementById('turnTag');
const statusTag = document.getElementById('statusTag');
const promoDlg = document.getElementById('promoDlg');

let sel = null;
let legal = [];

function draw(){
  boardEl.innerHTML='';
  const b = state.board;
  const coords = [...Array(8).keys()];
  const rows = flipped ? coords : coords.slice().reverse();
  const cols = flipped ? coords.slice().reverse() : coords;

  for(const r of rows){
    for(const c of cols){
      const p = b[r][c];
      const idx = (r+c)%2;
      const sq = document.createElement('div');
      sq.className = 'sq ' + (idx? 'dark':'light');
      sq.dataset.r = r; sq.dataset.c = c;
      if(sel && sel[0]===r && sel[1]===c) sq.classList.add('sel');

      if(sel){
        for(const m of legal){
          if(m.to[0]===r && m.to[1]===c){
            const t = b[r][c] ? document.createElement('div') : document.createElement('div');
            t.className = b[r][c] ? 'target' : 'dot';
            sq.appendChild(t);
          }
        }
      }
      if(p){
        const img = document.createElement('img');
        img.className = 'piece';
        img.alt = p;
        img.src = PIECE_IMG(p);
        sq.appendChild(img);
      }
      sq.addEventListener('click', onSq, {passive:true});
      boardEl.appendChild(sq);
    }
  }
  turnTag.textContent = 'Turn: ' + (state.active==='w'?'White':'Black');
  const res = isCheckmate(state) ? 'Checkmate' : isStalemate(state) ? 'Stalemate' : inCheck(state,state.active)? 'Check' : (rtc.connected?'Online':'Ready');
  statusTag.textContent = res;
  document.getElementById('undoBtn').disabled = rtc.connected; // avoid desyncs online
}

function onSq(e){
  const r = +e.currentTarget.dataset.r;
  const c = +e.currentTarget.dataset.c;
  const p = state.board[r][c];

  // No piece selected yet → select if it's the side to move
  if(!sel){
    if(p && colorOf(p) === state.active){
      sel=[r,c];
      legal = genMoves(state).filter(m=>m.from[0]===r && m.from[1]===c);
      draw();
    }
    return;
  }

  // Try to make a move first (more intuitive on touch)
  const cand = legal.find(m => m.to[0]===r && m.to[1]===c);
  if(cand){
    if(cand.promotion && !cand.promoteTo){
      openPromotion().then(pt=>{
        if(!pt){ sel=null; legal=[]; draw(); return; }
        cand.promoteTo = pt.toUpperCase();
        pushAndMove(cand);
      });
    }else{
      pushAndMove(cand);
    }
    return;
  }

  // Otherwise, if it's your piece → switch selection
  if(p && colorOf(p) === state.active){
    sel=[r,c];
    legal = genMoves(state).filter(m=>m.from[0]===r && m.from[1]===c);
    draw();
    return;
  }

  // Else clear selection
  sel=null; legal=[]; draw();
}

function openPromotion(){
  return new Promise(res=>{
    promoDlg.showModal();
    const handler = (e)=>{ const t=e.target.closest('.promo'); if(!t) return; promoDlg.close(); promoDlg.removeEventListener('click',handler); res(t.dataset.p); };
    promoDlg.addEventListener('click', handler);
  });
}

function appendMoveSAN(san){
  const ply = (history.length);
  const moveNo = Math.ceil(ply/2);
  if(ply%2===1){
    const line = document.createElement('div');
    line.id = 'm' + moveNo;
    line.innerHTML = `<strong>${moveNo}.</strong> ${san}`;
    movesEl.appendChild(line);
  }else{
    const line = document.getElementById('m'+moveNo);
    line.innerHTML = line.innerHTML + `  ${san}`;
  }
  movesEl.scrollTop = movesEl.scrollHeight;
}

document.getElementById('newBtn').onclick = ()=>{
  loadFEN(startFEN);
  if(rtc.connected){ send({t:'sync', fen: toFEN(state)}); }
};
document.getElementById('undoBtn').onclick = ()=>{
  if(rtc.connected){ alert('Undo is disabled during online play to avoid desync.'); return; }
  const prev = history.pop();
  if(prev){ state = prev; sel=null; legal=[]; draw(); }
};
document.getElementById('flipBtn').onclick = ()=>{ flipped=!flipped; draw(); };

/* ---------- P2P WebRTC (manual signaling) ---------- */
const RTC_CFG = { iceServers: [{urls: 'stun:stun.l.google.com:19302'}] };
let rtc = { pc:null, dc:null, isHost:false, connected:false };
let suppressSend = false;

function toUCI(m){
  const a = algebraic(m.from[0], m.from[1]);
  const b = algebraic(m.to[0], m.to[1]);
  return (a+b + (m.promotion ? (m.promoteTo||'Q').toLowerCase() : ''));
}
function moveFromUCI(uci){
  const from = uci.slice(0,2), to = uci.slice(2,4);
  const promo = uci.length>4 ? uci[4].toUpperCase() : null;
  const [fr,fc]=fromAlg(from), [tr,tc]=fromAlg(to);
  const legals = genMoves(state);
  const hit = legals.find(x => x.from[0]===fr && x.from[1]===fc && x.to[0]===tr && x.to[1]===tc && (!!promo === !!x.promotion));
  if(!hit) return null;
  if(promo) hit.promoteTo = promo;
  return hit;
}
function send(json){
  if(rtc.dc && rtc.dc.readyState==='open' && !suppressSend){
    rtc.dc.send(JSON.stringify(json));
  }
}
function attachDataChannel(dc){
  rtc.dc = dc;
  dc.onopen = ()=>{ rtc.connected=true; draw(); };
  dc.onclose = ()=>{ rtc.connected=false; draw(); };
  dc.onerror = ()=>{ statusTag.textContent = 'RTC error'; };
  dc.onmessage = (ev)=>{
    try{
      const msg = JSON.parse(ev.data);
      if(msg.t==='move'){
        const m = moveFromUCI(msg.uci);
        if(!m) return;
        suppressSend = true;
        pushAndMove(m);
        suppressSend = false;
      }else if(msg.t==='sync'){
        loadFEN(msg.fen);
      }
    }catch(e){}
  };
}
async function gatherComplete(pc){
  if(pc.iceGatheringState === 'complete') return;
  await new Promise(res=>{
    pc.addEventListener('icegatheringstatechange', ()=> {
      if(pc.iceGatheringState === 'complete') res();
    });
  });
}

const hostBtn = document.getElementById('hostBtn');
const joinBtn = document.getElementById('joinBtn');
const hostDlg = document.getElementById('hostDlg');
const joinDlg = document.getElementById('joinDlg');
const offerOut = document.getElementById('offerOut');
const answerIn = document.getElementById('answerIn');
const offerIn  = document.getElementById('offerIn');
const answerOut= document.getElementById('answerOut');
const offerQR  = document.getElementById('offerQR');
const answerQR = document.getElementById('answerQR');

function makeQR(imgEl, text){
  const payload = encodeURIComponent(text);
  const size = 300; // px
  imgEl.src = `https://chart.googleapis.com/chart?cht=qr&chs=${size}x${size}&chld=M|0&chl=${payload}`;
}

async function hostOnline(){
  rtc.isHost = true;
  rtc.pc = new RTCPeerConnection(RTC_CFG);
  attachDataChannel(rtc.pc.createDataChannel('chess'));
  rtc.pc.onicecandidate = ()=>{};
  const offer = await rtc.pc.createOffer();
  await rtc.pc.setLocalDescription(offer);
  await gatherComplete(rtc.pc);
  const blob = btoa(JSON.stringify(rtc.pc.localDescription));
  offerOut.value = blob;
  makeQR(offerQR, blob);
  document.getElementById('copyOfferBtn').onclick = ()=> navigator.clipboard.writeText(offerOut.value);
  document.getElementById('connectBtn').onclick = async ()=>{
    try{
      const ans = JSON.parse(atob(answerIn.value.trim()));
      await rtc.pc.setRemoteDescription(ans);
      hostDlg.close();
      send({t:'sync', fen: toFEN(state)});
    }catch(e){ alert('Could not parse the answer. Make sure you pasted it fully.'); }
  };
}

async function joinOnline(offerBlob){
  rtc.isHost = false;
  rtc.pc = new RTCPeerConnection(RTC_CFG);
  rtc.pc.ondatachannel = (ev)=> attachDataChannel(ev.channel);
  rtc.pc.onicecandidate = ()=>{};
  try{
    const offer = JSON.parse(atob(offerBlob));
    await rtc.pc.setRemoteDescription(offer);
    const answer = await rtc.pc.createAnswer();
    await rtc.pc.setLocalDescription(answer);
    await gatherComplete(rtc.pc);
    const blob = btoa(JSON.stringify(rtc.pc.localDescription));
    answerOut.value = blob;
    makeQR(answerQR, blob);
    document.getElementById('copyAnswerBtn').onclick = ()=> navigator.clipboard.writeText(answerOut.value);
  }catch(e){ /* wait for full paste or bad data */ }
}

hostBtn.onclick = ()=>{
  hostDlg.showModal();
  hostOnline();
};
joinBtn.onclick = ()=>{
  joinDlg.showModal();
  offerIn.oninput = ()=> {
    const v = offerIn.value.trim();
    if(v.length>0){ joinOnline(v); }
  };
};

/* Hook into pushAndMove to broadcast */
const _pushAndMove = function(m){
  const before = structuredClone(state);
  history.push(before);
  const after = makeMove(state, m);
  const san = toSAN(before, m, after);
  appendMoveSAN(san);
  sel=null; legal=[];
  draw();
};
function pushAndMove(m){
  const wasOnline = rtc.connected && !suppressSend;
  _pushAndMove(m);
  if(wasOnline){ send({t:'move', uci: toUCI(m)}); }
}

/* ---------- Init ---------- */
loadFEN(startFEN);
</script>
</body>
</html>
